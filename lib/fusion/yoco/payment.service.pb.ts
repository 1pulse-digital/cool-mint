// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: yoco/payment.service.proto
/* eslint-disable */

import type { ByteSource, PartialDeep } from "protoscript";
import * as protoscript from "protoscript";
import { JSONrequest, PBrequest } from "twirpscript";
// This is the minimum version supported by the current runtime.
// If this line fails typechecking, breaking changes have been introduced and this
// file needs to be regenerated by running `npx twirpscript`.
export { MIN_SUPPORTED_VERSION_0_0_56 } from "twirpscript";
import type { ClientConfiguration } from "twirpscript";
import * as yocoPayment from "./payment.pb";

//========================================//
//                 Types                  //
//========================================//

export interface ValidateSignatureRequest {
  webhookId: string;
  timestamp: bigint;
  signedContent: string;
  signature: string;
}

export interface ValidateSignatureResponse {
  valid: boolean;
}

export interface HandleSuccessfulPaymentRequest {
  payment: yocoPayment.Payment;
}

export interface CreateCheckoutRequest {
  /**
   * The final amount you would like to charge the customer, in cents. Including all the discounts and
   * applicable taxes.
   */
  amount: bigint;
  /**
   * The 3-letter currency code in ISO 4217 format. Currently we only support ZAR.
   */
  currency: string;
  /**
   * The URL to redirect customers to when the checkout is cancelled.
   */
  cancelUrl: string;
  /**
   * The URL to optionally redirect customers to when the checkout completes successfully.
   */
  successUrl: string;
  /**
   * The URL to optionally redirect customers to when the checkout does not complete successfully.
   */
  failureUrl: string;
  /**
   * Used to record additional details about the checkout, often used to reconcile data with an external system.
   */
  metadata: Record<string, CreateCheckoutRequest.Metadata["value"] | undefined>;
  /**
   * The total discount, in cents, is used for display only. It must already be included in the amount to collect.
   */
  totalDiscount: bigint;
  /**
   * The total tax, in cents, is used for display only. It must already be included in the amount to collect.
   */
  totalTaxAmount: bigint;
  /**
   * The subtotal, in cents, is used for display only and represents the total value collected including taxes and excluding discounts.
   */
  subtotalAmount: bigint;
  /**
   * The line items are used for display only and provide additional details for the items purchased during checkout.
   */
  lineItems: LineItem[];
}

export declare namespace CreateCheckoutRequest {
  interface Metadata {
    key: string;
    value: string;
  }
}

export interface CheckoutResponse {
  /**
   * The unique identifier for the checkout.
   */
  id: string;
  /**
   * The unique identifier for the payment.
   */
  paymentId: string;
  /**
   * The URL to redirect customers to in order to complete the checkout.
   */
  redirectUrl: string;
  /**
   * The status of the checkout, one of created, started, processing, completed or refunded.
   */
  status: string;
  /**
   * The final amount you would like to charge the customer, in cents. Including all the discounts and applicable taxes.
   */
  amount: bigint;
  /**
   * The 3-letter currency code in ISO 4217 format. Currently we only support ZAR.
   */
  currency: string;
  /**
   * The URL to optionally redirect customers to when the checkout completes successfully.
   */
  successUrl: string;
  /**
   * The URL to redirect customers to when the checkout is cancelled.
   */
  cancelUrl: string;
  /**
   * The URL to optionally redirect customers to when the checkout does not complete successfully.
   */
  failureUrl: string;
  /**
   * Used to record additional details about the checkout, often used to reconcile data with an external system.
   */
  metadata: Record<string, CheckoutResponse.Metadata["value"] | undefined>;
  /**
   * Reference used internally to identify the merchant.
   */
  merchantId: string;
  /**
   * The total discount, in cents, is used for display only. It must already be included in the amount to collect.
   */
  totalDiscount: bigint;
  /**
   * The total tax, in cents, is used for display only. It must already be included in the amount to collect.
   */
  totalTaxAmount: bigint;
  /**
   * The subtotal, in cents, is used for display only and represents the total value collected including taxes and excluding discounts.
   */
  subtotalAmount: bigint;
  /**
   * The line items are used for display only and provide additional details for the items purchased during checkout.
   */
  lineItems: LineItem[];
  /**
   * The mode of the checkout, as determined from the key used to create the checkout. One of either live or test.
   */
  processingMode: string;
}

export declare namespace CheckoutResponse {
  interface Metadata {
    key: string;
    value: string;
  }
}

export interface RegisterHookRequest {
  name: string;
  url: string;
}

export interface RegisterHookResponse {
  id: string;
  name: string;
  url: string;
  mode: string;
  secret: string;
}

export interface ListHooksRequest {}

export interface ListHooksResponse {
  subscriptions: ListHooksResponse.Subscriptions[];
}

export declare namespace ListHooksResponse {
  export interface Subscriptions {
    id: string;
    name: string;
    url: string;
    mode: string;
  }
}

export interface DeleteHookRequest {
  id: string;
}

export interface DeleteHookResponse {
  message: string;
}

export interface LineItem {
  displayName: string;
  description: string;
  quantity: number;
  pricingDetails: PricingDetails;
}

export interface PricingDetails {
  price: bigint;
}

//========================================//
//     PaymentService Protobuf Client     //
//========================================//

/**
 * CreateCheckout will create a new checkout
 * See: https://developer.yoco.com/online/api-reference/checkout/payments/accept-payments/
 */
export async function CreateCheckout(
  createCheckoutRequest: CreateCheckoutRequest,
  config?: ClientConfiguration,
): Promise<CheckoutResponse> {
  const response = await PBrequest(
    "/yoco.PaymentService/CreateCheckout",
    CreateCheckoutRequest.encode(createCheckoutRequest),
    config,
  );
  return CheckoutResponse.decode(response);
}

export async function ValidateSignature(
  validateSignatureRequest: ValidateSignatureRequest,
  config?: ClientConfiguration,
): Promise<ValidateSignatureResponse> {
  const response = await PBrequest(
    "/yoco.PaymentService/ValidateSignature",
    ValidateSignatureRequest.encode(validateSignatureRequest),
    config,
  );
  return ValidateSignatureResponse.decode(response);
}

export async function RegisterHook(
  registerHookRequest: RegisterHookRequest,
  config?: ClientConfiguration,
): Promise<RegisterHookResponse> {
  const response = await PBrequest(
    "/yoco.PaymentService/RegisterHook",
    RegisterHookRequest.encode(registerHookRequest),
    config,
  );
  return RegisterHookResponse.decode(response);
}

export async function ListHooks(
  listHooksRequest: ListHooksRequest,
  config?: ClientConfiguration,
): Promise<ListHooksResponse> {
  const response = await PBrequest(
    "/yoco.PaymentService/ListHooks",
    ListHooksRequest.encode(listHooksRequest),
    config,
  );
  return ListHooksResponse.decode(response);
}

export async function DeleteHook(
  deleteHookRequest: DeleteHookRequest,
  config?: ClientConfiguration,
): Promise<DeleteHookResponse> {
  const response = await PBrequest(
    "/yoco.PaymentService/DeleteHook",
    DeleteHookRequest.encode(deleteHookRequest),
    config,
  );
  return DeleteHookResponse.decode(response);
}

/**
 * See: https://developer.yoco.com/online/api-reference/webhooks/accept-events/#1-create-the-webhook-endpoint
 */
export async function HandleSuccessfulPayment(
  handleSuccessfulPaymentRequest: HandleSuccessfulPaymentRequest,
  config?: ClientConfiguration,
): Promise<protoscript.Empty> {
  const response = await PBrequest(
    "/yoco.PaymentService/HandleSuccessfulPayment",
    HandleSuccessfulPaymentRequest.encode(handleSuccessfulPaymentRequest),
    config,
  );
  return protoscript.Empty.decode(response);
}

//========================================//
//       PaymentService JSON Client       //
//========================================//

/**
 * CreateCheckout will create a new checkout
 * See: https://developer.yoco.com/online/api-reference/checkout/payments/accept-payments/
 */
export async function CreateCheckoutJSON(
  createCheckoutRequest: CreateCheckoutRequest,
  config?: ClientConfiguration,
): Promise<CheckoutResponse> {
  const response = await JSONrequest(
    "/yoco.PaymentService/CreateCheckout",
    CreateCheckoutRequestJSON.encode(createCheckoutRequest),
    config,
  );
  return CheckoutResponseJSON.decode(response);
}

export async function ValidateSignatureJSON(
  validateSignatureRequest: ValidateSignatureRequest,
  config?: ClientConfiguration,
): Promise<ValidateSignatureResponse> {
  const response = await JSONrequest(
    "/yoco.PaymentService/ValidateSignature",
    ValidateSignatureRequestJSON.encode(validateSignatureRequest),
    config,
  );
  return ValidateSignatureResponseJSON.decode(response);
}

export async function RegisterHookJSON(
  registerHookRequest: RegisterHookRequest,
  config?: ClientConfiguration,
): Promise<RegisterHookResponse> {
  const response = await JSONrequest(
    "/yoco.PaymentService/RegisterHook",
    RegisterHookRequestJSON.encode(registerHookRequest),
    config,
  );
  return RegisterHookResponseJSON.decode(response);
}

export async function ListHooksJSON(
  listHooksRequest: ListHooksRequest,
  config?: ClientConfiguration,
): Promise<ListHooksResponse> {
  const response = await JSONrequest(
    "/yoco.PaymentService/ListHooks",
    ListHooksRequestJSON.encode(listHooksRequest),
    config,
  );
  return ListHooksResponseJSON.decode(response);
}

export async function DeleteHookJSON(
  deleteHookRequest: DeleteHookRequest,
  config?: ClientConfiguration,
): Promise<DeleteHookResponse> {
  const response = await JSONrequest(
    "/yoco.PaymentService/DeleteHook",
    DeleteHookRequestJSON.encode(deleteHookRequest),
    config,
  );
  return DeleteHookResponseJSON.decode(response);
}

/**
 * See: https://developer.yoco.com/online/api-reference/webhooks/accept-events/#1-create-the-webhook-endpoint
 */
export async function HandleSuccessfulPaymentJSON(
  handleSuccessfulPaymentRequest: HandleSuccessfulPaymentRequest,
  config?: ClientConfiguration,
): Promise<protoscript.Empty> {
  const response = await JSONrequest(
    "/yoco.PaymentService/HandleSuccessfulPayment",
    HandleSuccessfulPaymentRequestJSON.encode(handleSuccessfulPaymentRequest),
    config,
  );
  return protoscript.EmptyJSON.decode(response);
}

//========================================//
//             PaymentService             //
//========================================//

export interface PaymentService<Context = unknown> {
  /**
   * CreateCheckout will create a new checkout
   * See: https://developer.yoco.com/online/api-reference/checkout/payments/accept-payments/
   */
  CreateCheckout: (
    createCheckoutRequest: CreateCheckoutRequest,
    context: Context,
  ) => Promise<CheckoutResponse> | CheckoutResponse;
  ValidateSignature: (
    validateSignatureRequest: ValidateSignatureRequest,
    context: Context,
  ) => Promise<ValidateSignatureResponse> | ValidateSignatureResponse;
  RegisterHook: (
    registerHookRequest: RegisterHookRequest,
    context: Context,
  ) => Promise<RegisterHookResponse> | RegisterHookResponse;
  ListHooks: (
    listHooksRequest: ListHooksRequest,
    context: Context,
  ) => Promise<ListHooksResponse> | ListHooksResponse;
  DeleteHook: (
    deleteHookRequest: DeleteHookRequest,
    context: Context,
  ) => Promise<DeleteHookResponse> | DeleteHookResponse;
  /**
   * See: https://developer.yoco.com/online/api-reference/webhooks/accept-events/#1-create-the-webhook-endpoint
   */
  HandleSuccessfulPayment: (
    handleSuccessfulPaymentRequest: HandleSuccessfulPaymentRequest,
    context: Context,
  ) => Promise<protoscript.Empty> | protoscript.Empty;
}

export function createPaymentService<Context>(
  service: PaymentService<Context>,
) {
  return {
    name: "yoco.PaymentService",
    methods: {
      CreateCheckout: {
        name: "CreateCheckout",
        handler: service.CreateCheckout,
        input: {
          protobuf: CreateCheckoutRequest,
          json: CreateCheckoutRequestJSON,
        },
        output: { protobuf: CheckoutResponse, json: CheckoutResponseJSON },
      },
      ValidateSignature: {
        name: "ValidateSignature",
        handler: service.ValidateSignature,
        input: {
          protobuf: ValidateSignatureRequest,
          json: ValidateSignatureRequestJSON,
        },
        output: {
          protobuf: ValidateSignatureResponse,
          json: ValidateSignatureResponseJSON,
        },
      },
      RegisterHook: {
        name: "RegisterHook",
        handler: service.RegisterHook,
        input: { protobuf: RegisterHookRequest, json: RegisterHookRequestJSON },
        output: {
          protobuf: RegisterHookResponse,
          json: RegisterHookResponseJSON,
        },
      },
      ListHooks: {
        name: "ListHooks",
        handler: service.ListHooks,
        input: { protobuf: ListHooksRequest, json: ListHooksRequestJSON },
        output: { protobuf: ListHooksResponse, json: ListHooksResponseJSON },
      },
      DeleteHook: {
        name: "DeleteHook",
        handler: service.DeleteHook,
        input: { protobuf: DeleteHookRequest, json: DeleteHookRequestJSON },
        output: { protobuf: DeleteHookResponse, json: DeleteHookResponseJSON },
      },
      HandleSuccessfulPayment: {
        name: "HandleSuccessfulPayment",
        handler: service.HandleSuccessfulPayment,
        input: {
          protobuf: HandleSuccessfulPaymentRequest,
          json: HandleSuccessfulPaymentRequestJSON,
        },
        output: { protobuf: protoscript.Empty, json: protoscript.EmptyJSON },
      },
    },
  } as const;
}

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const ValidateSignatureRequest = {
  /**
   * Serializes ValidateSignatureRequest to protobuf.
   */
  encode: function (msg: PartialDeep<ValidateSignatureRequest>): Uint8Array {
    return ValidateSignatureRequest._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes ValidateSignatureRequest from protobuf.
   */
  decode: function (bytes: ByteSource): ValidateSignatureRequest {
    return ValidateSignatureRequest._readMessage(
      ValidateSignatureRequest.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes ValidateSignatureRequest with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<ValidateSignatureRequest>,
  ): ValidateSignatureRequest {
    return {
      webhookId: "",
      timestamp: 0n,
      signedContent: "",
      signature: "",
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<ValidateSignatureRequest>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.webhookId) {
      writer.writeString(1, msg.webhookId);
    }
    if (msg.timestamp) {
      writer.writeInt64String(2, msg.timestamp.toString() as any);
    }
    if (msg.signedContent) {
      writer.writeString(3, msg.signedContent);
    }
    if (msg.signature) {
      writer.writeString(4, msg.signature);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: ValidateSignatureRequest,
    reader: protoscript.BinaryReader,
  ): ValidateSignatureRequest {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.webhookId = reader.readString();
          break;
        }
        case 2: {
          msg.timestamp = BigInt(reader.readInt64String());
          break;
        }
        case 3: {
          msg.signedContent = reader.readString();
          break;
        }
        case 4: {
          msg.signature = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const ValidateSignatureResponse = {
  /**
   * Serializes ValidateSignatureResponse to protobuf.
   */
  encode: function (msg: PartialDeep<ValidateSignatureResponse>): Uint8Array {
    return ValidateSignatureResponse._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes ValidateSignatureResponse from protobuf.
   */
  decode: function (bytes: ByteSource): ValidateSignatureResponse {
    return ValidateSignatureResponse._readMessage(
      ValidateSignatureResponse.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes ValidateSignatureResponse with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<ValidateSignatureResponse>,
  ): ValidateSignatureResponse {
    return {
      valid: false,
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<ValidateSignatureResponse>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.valid) {
      writer.writeBool(1, msg.valid);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: ValidateSignatureResponse,
    reader: protoscript.BinaryReader,
  ): ValidateSignatureResponse {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.valid = reader.readBool();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const HandleSuccessfulPaymentRequest = {
  /**
   * Serializes HandleSuccessfulPaymentRequest to protobuf.
   */
  encode: function (
    msg: PartialDeep<HandleSuccessfulPaymentRequest>,
  ): Uint8Array {
    return HandleSuccessfulPaymentRequest._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes HandleSuccessfulPaymentRequest from protobuf.
   */
  decode: function (bytes: ByteSource): HandleSuccessfulPaymentRequest {
    return HandleSuccessfulPaymentRequest._readMessage(
      HandleSuccessfulPaymentRequest.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes HandleSuccessfulPaymentRequest with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<HandleSuccessfulPaymentRequest>,
  ): HandleSuccessfulPaymentRequest {
    return {
      payment: yocoPayment.Payment.initialize(),
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<HandleSuccessfulPaymentRequest>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.payment) {
      writer.writeMessage(1, msg.payment, yocoPayment.Payment._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: HandleSuccessfulPaymentRequest,
    reader: protoscript.BinaryReader,
  ): HandleSuccessfulPaymentRequest {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.payment, yocoPayment.Payment._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const CreateCheckoutRequest = {
  /**
   * Serializes CreateCheckoutRequest to protobuf.
   */
  encode: function (msg: PartialDeep<CreateCheckoutRequest>): Uint8Array {
    return CreateCheckoutRequest._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes CreateCheckoutRequest from protobuf.
   */
  decode: function (bytes: ByteSource): CreateCheckoutRequest {
    return CreateCheckoutRequest._readMessage(
      CreateCheckoutRequest.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes CreateCheckoutRequest with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<CreateCheckoutRequest>,
  ): CreateCheckoutRequest {
    return {
      amount: 0n,
      currency: "",
      cancelUrl: "",
      successUrl: "",
      failureUrl: "",
      metadata: {},
      totalDiscount: 0n,
      totalTaxAmount: 0n,
      subtotalAmount: 0n,
      lineItems: [],
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<CreateCheckoutRequest>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.amount) {
      writer.writeInt64String(1, msg.amount.toString() as any);
    }
    if (msg.currency) {
      writer.writeString(2, msg.currency);
    }
    if (msg.cancelUrl) {
      writer.writeString(3, msg.cancelUrl);
    }
    if (msg.successUrl) {
      writer.writeString(4, msg.successUrl);
    }
    if (msg.failureUrl) {
      writer.writeString(5, msg.failureUrl);
    }
    if (msg.metadata) {
      writer.writeRepeatedMessage(
        6,
        Object.entries(msg.metadata).map(([key, value]) => ({
          key: key as any,
          value: value as any,
        })) as any,
        CreateCheckoutRequest.Metadata._writeMessage,
      );
    }
    if (msg.totalDiscount) {
      writer.writeInt64String(7, msg.totalDiscount.toString() as any);
    }
    if (msg.totalTaxAmount) {
      writer.writeInt64String(8, msg.totalTaxAmount.toString() as any);
    }
    if (msg.subtotalAmount) {
      writer.writeInt64String(9, msg.subtotalAmount.toString() as any);
    }
    if (msg.lineItems?.length) {
      writer.writeRepeatedMessage(
        10,
        msg.lineItems as any,
        LineItem._writeMessage,
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: CreateCheckoutRequest,
    reader: protoscript.BinaryReader,
  ): CreateCheckoutRequest {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.amount = BigInt(reader.readInt64String());
          break;
        }
        case 2: {
          msg.currency = reader.readString();
          break;
        }
        case 3: {
          msg.cancelUrl = reader.readString();
          break;
        }
        case 4: {
          msg.successUrl = reader.readString();
          break;
        }
        case 5: {
          msg.failureUrl = reader.readString();
          break;
        }
        case 6: {
          const map = {} as CreateCheckoutRequest.Metadata;
          reader.readMessage(map, CreateCheckoutRequest.Metadata._readMessage);
          msg.metadata[map.key.toString()] = map.value;
          break;
        }
        case 7: {
          msg.totalDiscount = BigInt(reader.readInt64String());
          break;
        }
        case 8: {
          msg.totalTaxAmount = BigInt(reader.readInt64String());
          break;
        }
        case 9: {
          msg.subtotalAmount = BigInt(reader.readInt64String());
          break;
        }
        case 10: {
          const m = LineItem.initialize();
          reader.readMessage(m, LineItem._readMessage);
          msg.lineItems.push(m);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  Metadata: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<CreateCheckoutRequest.Metadata>,
      writer: protoscript.BinaryWriter,
    ): protoscript.BinaryWriter {
      if (msg.key) {
        writer.writeString(1, msg.key);
      }
      if (msg.value) {
        writer.writeString(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: CreateCheckoutRequest.Metadata,
      reader: protoscript.BinaryReader,
    ): CreateCheckoutRequest.Metadata {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readString();
            break;
          }
          case 2: {
            msg.value = reader.readString();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const CheckoutResponse = {
  /**
   * Serializes CheckoutResponse to protobuf.
   */
  encode: function (msg: PartialDeep<CheckoutResponse>): Uint8Array {
    return CheckoutResponse._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes CheckoutResponse from protobuf.
   */
  decode: function (bytes: ByteSource): CheckoutResponse {
    return CheckoutResponse._readMessage(
      CheckoutResponse.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes CheckoutResponse with all fields set to their default value.
   */
  initialize: function (msg?: Partial<CheckoutResponse>): CheckoutResponse {
    return {
      id: "",
      paymentId: "",
      redirectUrl: "",
      status: "",
      amount: 0n,
      currency: "",
      successUrl: "",
      cancelUrl: "",
      failureUrl: "",
      metadata: {},
      merchantId: "",
      totalDiscount: 0n,
      totalTaxAmount: 0n,
      subtotalAmount: 0n,
      lineItems: [],
      processingMode: "",
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<CheckoutResponse>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.id) {
      writer.writeString(1, msg.id);
    }
    if (msg.paymentId) {
      writer.writeString(2, msg.paymentId);
    }
    if (msg.redirectUrl) {
      writer.writeString(3, msg.redirectUrl);
    }
    if (msg.status) {
      writer.writeString(4, msg.status);
    }
    if (msg.amount) {
      writer.writeInt64String(5, msg.amount.toString() as any);
    }
    if (msg.currency) {
      writer.writeString(6, msg.currency);
    }
    if (msg.successUrl) {
      writer.writeString(7, msg.successUrl);
    }
    if (msg.cancelUrl) {
      writer.writeString(8, msg.cancelUrl);
    }
    if (msg.failureUrl) {
      writer.writeString(9, msg.failureUrl);
    }
    if (msg.metadata) {
      writer.writeRepeatedMessage(
        10,
        Object.entries(msg.metadata).map(([key, value]) => ({
          key: key as any,
          value: value as any,
        })) as any,
        CheckoutResponse.Metadata._writeMessage,
      );
    }
    if (msg.merchantId) {
      writer.writeString(11, msg.merchantId);
    }
    if (msg.totalDiscount) {
      writer.writeInt64String(12, msg.totalDiscount.toString() as any);
    }
    if (msg.totalTaxAmount) {
      writer.writeInt64String(13, msg.totalTaxAmount.toString() as any);
    }
    if (msg.subtotalAmount) {
      writer.writeInt64String(14, msg.subtotalAmount.toString() as any);
    }
    if (msg.lineItems?.length) {
      writer.writeRepeatedMessage(
        15,
        msg.lineItems as any,
        LineItem._writeMessage,
      );
    }
    if (msg.processingMode) {
      writer.writeString(16, msg.processingMode);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: CheckoutResponse,
    reader: protoscript.BinaryReader,
  ): CheckoutResponse {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.id = reader.readString();
          break;
        }
        case 2: {
          msg.paymentId = reader.readString();
          break;
        }
        case 3: {
          msg.redirectUrl = reader.readString();
          break;
        }
        case 4: {
          msg.status = reader.readString();
          break;
        }
        case 5: {
          msg.amount = BigInt(reader.readInt64String());
          break;
        }
        case 6: {
          msg.currency = reader.readString();
          break;
        }
        case 7: {
          msg.successUrl = reader.readString();
          break;
        }
        case 8: {
          msg.cancelUrl = reader.readString();
          break;
        }
        case 9: {
          msg.failureUrl = reader.readString();
          break;
        }
        case 10: {
          const map = {} as CheckoutResponse.Metadata;
          reader.readMessage(map, CheckoutResponse.Metadata._readMessage);
          msg.metadata[map.key.toString()] = map.value;
          break;
        }
        case 11: {
          msg.merchantId = reader.readString();
          break;
        }
        case 12: {
          msg.totalDiscount = BigInt(reader.readInt64String());
          break;
        }
        case 13: {
          msg.totalTaxAmount = BigInt(reader.readInt64String());
          break;
        }
        case 14: {
          msg.subtotalAmount = BigInt(reader.readInt64String());
          break;
        }
        case 15: {
          const m = LineItem.initialize();
          reader.readMessage(m, LineItem._readMessage);
          msg.lineItems.push(m);
          break;
        }
        case 16: {
          msg.processingMode = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  Metadata: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<CheckoutResponse.Metadata>,
      writer: protoscript.BinaryWriter,
    ): protoscript.BinaryWriter {
      if (msg.key) {
        writer.writeString(1, msg.key);
      }
      if (msg.value) {
        writer.writeString(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: CheckoutResponse.Metadata,
      reader: protoscript.BinaryReader,
    ): CheckoutResponse.Metadata {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readString();
            break;
          }
          case 2: {
            msg.value = reader.readString();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const RegisterHookRequest = {
  /**
   * Serializes RegisterHookRequest to protobuf.
   */
  encode: function (msg: PartialDeep<RegisterHookRequest>): Uint8Array {
    return RegisterHookRequest._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes RegisterHookRequest from protobuf.
   */
  decode: function (bytes: ByteSource): RegisterHookRequest {
    return RegisterHookRequest._readMessage(
      RegisterHookRequest.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes RegisterHookRequest with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<RegisterHookRequest>,
  ): RegisterHookRequest {
    return {
      name: "",
      url: "",
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<RegisterHookRequest>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.name) {
      writer.writeString(1, msg.name);
    }
    if (msg.url) {
      writer.writeString(2, msg.url);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: RegisterHookRequest,
    reader: protoscript.BinaryReader,
  ): RegisterHookRequest {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.name = reader.readString();
          break;
        }
        case 2: {
          msg.url = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const RegisterHookResponse = {
  /**
   * Serializes RegisterHookResponse to protobuf.
   */
  encode: function (msg: PartialDeep<RegisterHookResponse>): Uint8Array {
    return RegisterHookResponse._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes RegisterHookResponse from protobuf.
   */
  decode: function (bytes: ByteSource): RegisterHookResponse {
    return RegisterHookResponse._readMessage(
      RegisterHookResponse.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes RegisterHookResponse with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<RegisterHookResponse>,
  ): RegisterHookResponse {
    return {
      id: "",
      name: "",
      url: "",
      mode: "",
      secret: "",
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<RegisterHookResponse>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.id) {
      writer.writeString(1, msg.id);
    }
    if (msg.name) {
      writer.writeString(2, msg.name);
    }
    if (msg.url) {
      writer.writeString(3, msg.url);
    }
    if (msg.mode) {
      writer.writeString(4, msg.mode);
    }
    if (msg.secret) {
      writer.writeString(5, msg.secret);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: RegisterHookResponse,
    reader: protoscript.BinaryReader,
  ): RegisterHookResponse {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.id = reader.readString();
          break;
        }
        case 2: {
          msg.name = reader.readString();
          break;
        }
        case 3: {
          msg.url = reader.readString();
          break;
        }
        case 4: {
          msg.mode = reader.readString();
          break;
        }
        case 5: {
          msg.secret = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const ListHooksRequest = {
  /**
   * Serializes ListHooksRequest to protobuf.
   */
  encode: function (_msg?: PartialDeep<ListHooksRequest>): Uint8Array {
    return new Uint8Array();
  },

  /**
   * Deserializes ListHooksRequest from protobuf.
   */
  decode: function (_bytes?: ByteSource): ListHooksRequest {
    return {};
  },

  /**
   * Initializes ListHooksRequest with all fields set to their default value.
   */
  initialize: function (msg?: Partial<ListHooksRequest>): ListHooksRequest {
    return {
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    _msg: PartialDeep<ListHooksRequest>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    _msg: ListHooksRequest,
    _reader: protoscript.BinaryReader,
  ): ListHooksRequest {
    return _msg;
  },
};

export const ListHooksResponse = {
  /**
   * Serializes ListHooksResponse to protobuf.
   */
  encode: function (msg: PartialDeep<ListHooksResponse>): Uint8Array {
    return ListHooksResponse._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes ListHooksResponse from protobuf.
   */
  decode: function (bytes: ByteSource): ListHooksResponse {
    return ListHooksResponse._readMessage(
      ListHooksResponse.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes ListHooksResponse with all fields set to their default value.
   */
  initialize: function (msg?: Partial<ListHooksResponse>): ListHooksResponse {
    return {
      subscriptions: [],
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<ListHooksResponse>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.subscriptions?.length) {
      writer.writeRepeatedMessage(
        1,
        msg.subscriptions as any,
        ListHooksResponse.Subscriptions._writeMessage,
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: ListHooksResponse,
    reader: protoscript.BinaryReader,
  ): ListHooksResponse {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const m = ListHooksResponse.Subscriptions.initialize();
          reader.readMessage(m, ListHooksResponse.Subscriptions._readMessage);
          msg.subscriptions.push(m);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  Subscriptions: {
    /**
     * Serializes ListHooksResponse.Subscriptions to protobuf.
     */
    encode: function (
      msg: PartialDeep<ListHooksResponse.Subscriptions>,
    ): Uint8Array {
      return ListHooksResponse.Subscriptions._writeMessage(
        msg,
        new protoscript.BinaryWriter(),
      ).getResultBuffer();
    },

    /**
     * Deserializes ListHooksResponse.Subscriptions from protobuf.
     */
    decode: function (bytes: ByteSource): ListHooksResponse.Subscriptions {
      return ListHooksResponse.Subscriptions._readMessage(
        ListHooksResponse.Subscriptions.initialize(),
        new protoscript.BinaryReader(bytes),
      );
    },

    /**
     * Initializes ListHooksResponse.Subscriptions with all fields set to their default value.
     */
    initialize: function (
      msg?: Partial<ListHooksResponse.Subscriptions>,
    ): ListHooksResponse.Subscriptions {
      return {
        id: "",
        name: "",
        url: "",
        mode: "",
        ...msg,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<ListHooksResponse.Subscriptions>,
      writer: protoscript.BinaryWriter,
    ): protoscript.BinaryWriter {
      if (msg.id) {
        writer.writeString(1, msg.id);
      }
      if (msg.name) {
        writer.writeString(2, msg.name);
      }
      if (msg.url) {
        writer.writeString(3, msg.url);
      }
      if (msg.mode) {
        writer.writeString(4, msg.mode);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: ListHooksResponse.Subscriptions,
      reader: protoscript.BinaryReader,
    ): ListHooksResponse.Subscriptions {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.id = reader.readString();
            break;
          }
          case 2: {
            msg.name = reader.readString();
            break;
          }
          case 3: {
            msg.url = reader.readString();
            break;
          }
          case 4: {
            msg.mode = reader.readString();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const DeleteHookRequest = {
  /**
   * Serializes DeleteHookRequest to protobuf.
   */
  encode: function (msg: PartialDeep<DeleteHookRequest>): Uint8Array {
    return DeleteHookRequest._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes DeleteHookRequest from protobuf.
   */
  decode: function (bytes: ByteSource): DeleteHookRequest {
    return DeleteHookRequest._readMessage(
      DeleteHookRequest.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes DeleteHookRequest with all fields set to their default value.
   */
  initialize: function (msg?: Partial<DeleteHookRequest>): DeleteHookRequest {
    return {
      id: "",
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<DeleteHookRequest>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.id) {
      writer.writeString(1, msg.id);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: DeleteHookRequest,
    reader: protoscript.BinaryReader,
  ): DeleteHookRequest {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.id = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const DeleteHookResponse = {
  /**
   * Serializes DeleteHookResponse to protobuf.
   */
  encode: function (msg: PartialDeep<DeleteHookResponse>): Uint8Array {
    return DeleteHookResponse._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes DeleteHookResponse from protobuf.
   */
  decode: function (bytes: ByteSource): DeleteHookResponse {
    return DeleteHookResponse._readMessage(
      DeleteHookResponse.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes DeleteHookResponse with all fields set to their default value.
   */
  initialize: function (msg?: Partial<DeleteHookResponse>): DeleteHookResponse {
    return {
      message: "",
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<DeleteHookResponse>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.message) {
      writer.writeString(1, msg.message);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: DeleteHookResponse,
    reader: protoscript.BinaryReader,
  ): DeleteHookResponse {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.message = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const LineItem = {
  /**
   * Serializes LineItem to protobuf.
   */
  encode: function (msg: PartialDeep<LineItem>): Uint8Array {
    return LineItem._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes LineItem from protobuf.
   */
  decode: function (bytes: ByteSource): LineItem {
    return LineItem._readMessage(
      LineItem.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes LineItem with all fields set to their default value.
   */
  initialize: function (msg?: Partial<LineItem>): LineItem {
    return {
      displayName: "",
      description: "",
      quantity: 0,
      pricingDetails: PricingDetails.initialize(),
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<LineItem>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.displayName) {
      writer.writeString(1, msg.displayName);
    }
    if (msg.description) {
      writer.writeString(2, msg.description);
    }
    if (msg.quantity) {
      writer.writeInt32(3, msg.quantity);
    }
    if (msg.pricingDetails) {
      writer.writeMessage(4, msg.pricingDetails, PricingDetails._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: LineItem,
    reader: protoscript.BinaryReader,
  ): LineItem {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.displayName = reader.readString();
          break;
        }
        case 2: {
          msg.description = reader.readString();
          break;
        }
        case 3: {
          msg.quantity = reader.readInt32();
          break;
        }
        case 4: {
          reader.readMessage(msg.pricingDetails, PricingDetails._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const PricingDetails = {
  /**
   * Serializes PricingDetails to protobuf.
   */
  encode: function (msg: PartialDeep<PricingDetails>): Uint8Array {
    return PricingDetails._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes PricingDetails from protobuf.
   */
  decode: function (bytes: ByteSource): PricingDetails {
    return PricingDetails._readMessage(
      PricingDetails.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes PricingDetails with all fields set to their default value.
   */
  initialize: function (msg?: Partial<PricingDetails>): PricingDetails {
    return {
      price: 0n,
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<PricingDetails>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.price) {
      writer.writeInt64String(1, msg.price.toString() as any);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: PricingDetails,
    reader: protoscript.BinaryReader,
  ): PricingDetails {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.price = BigInt(reader.readInt64String());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

//========================================//
//          JSON Encode / Decode          //
//========================================//

export const ValidateSignatureRequestJSON = {
  /**
   * Serializes ValidateSignatureRequest to JSON.
   */
  encode: function (msg: PartialDeep<ValidateSignatureRequest>): string {
    return JSON.stringify(ValidateSignatureRequestJSON._writeMessage(msg));
  },

  /**
   * Deserializes ValidateSignatureRequest from JSON.
   */
  decode: function (json: string): ValidateSignatureRequest {
    return ValidateSignatureRequestJSON._readMessage(
      ValidateSignatureRequestJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes ValidateSignatureRequest with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<ValidateSignatureRequest>,
  ): ValidateSignatureRequest {
    return {
      webhookId: "",
      timestamp: 0n,
      signedContent: "",
      signature: "",
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<ValidateSignatureRequest>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.webhookId) {
      json["webhookId"] = msg.webhookId;
    }
    if (msg.timestamp) {
      json["timestamp"] = String(msg.timestamp);
    }
    if (msg.signedContent) {
      json["signedContent"] = msg.signedContent;
    }
    if (msg.signature) {
      json["signature"] = msg.signature;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: ValidateSignatureRequest,
    json: any,
  ): ValidateSignatureRequest {
    const _webhookId_ = json["webhookId"];
    if (_webhookId_) {
      msg.webhookId = _webhookId_;
    }
    const _timestamp_ = json["timestamp"];
    if (_timestamp_) {
      msg.timestamp = BigInt(_timestamp_);
    }
    const _signedContent_ = json["signedContent"];
    if (_signedContent_) {
      msg.signedContent = _signedContent_;
    }
    const _signature_ = json["signature"];
    if (_signature_) {
      msg.signature = _signature_;
    }
    return msg;
  },
};

export const ValidateSignatureResponseJSON = {
  /**
   * Serializes ValidateSignatureResponse to JSON.
   */
  encode: function (msg: PartialDeep<ValidateSignatureResponse>): string {
    return JSON.stringify(ValidateSignatureResponseJSON._writeMessage(msg));
  },

  /**
   * Deserializes ValidateSignatureResponse from JSON.
   */
  decode: function (json: string): ValidateSignatureResponse {
    return ValidateSignatureResponseJSON._readMessage(
      ValidateSignatureResponseJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes ValidateSignatureResponse with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<ValidateSignatureResponse>,
  ): ValidateSignatureResponse {
    return {
      valid: false,
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<ValidateSignatureResponse>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.valid) {
      json["valid"] = msg.valid;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: ValidateSignatureResponse,
    json: any,
  ): ValidateSignatureResponse {
    const _valid_ = json["valid"];
    if (_valid_) {
      msg.valid = _valid_;
    }
    return msg;
  },
};

export const HandleSuccessfulPaymentRequestJSON = {
  /**
   * Serializes HandleSuccessfulPaymentRequest to JSON.
   */
  encode: function (msg: PartialDeep<HandleSuccessfulPaymentRequest>): string {
    return JSON.stringify(
      HandleSuccessfulPaymentRequestJSON._writeMessage(msg),
    );
  },

  /**
   * Deserializes HandleSuccessfulPaymentRequest from JSON.
   */
  decode: function (json: string): HandleSuccessfulPaymentRequest {
    return HandleSuccessfulPaymentRequestJSON._readMessage(
      HandleSuccessfulPaymentRequestJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes HandleSuccessfulPaymentRequest with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<HandleSuccessfulPaymentRequest>,
  ): HandleSuccessfulPaymentRequest {
    return {
      payment: yocoPayment.PaymentJSON.initialize(),
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<HandleSuccessfulPaymentRequest>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.payment) {
      const _payment_ = yocoPayment.PaymentJSON._writeMessage(msg.payment);
      if (Object.keys(_payment_).length > 0) {
        json["payment"] = _payment_;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: HandleSuccessfulPaymentRequest,
    json: any,
  ): HandleSuccessfulPaymentRequest {
    const _payment_ = json["payment"];
    if (_payment_) {
      yocoPayment.PaymentJSON._readMessage(msg.payment, _payment_);
    }
    return msg;
  },
};

export const CreateCheckoutRequestJSON = {
  /**
   * Serializes CreateCheckoutRequest to JSON.
   */
  encode: function (msg: PartialDeep<CreateCheckoutRequest>): string {
    return JSON.stringify(CreateCheckoutRequestJSON._writeMessage(msg));
  },

  /**
   * Deserializes CreateCheckoutRequest from JSON.
   */
  decode: function (json: string): CreateCheckoutRequest {
    return CreateCheckoutRequestJSON._readMessage(
      CreateCheckoutRequestJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes CreateCheckoutRequest with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<CreateCheckoutRequest>,
  ): CreateCheckoutRequest {
    return {
      amount: 0n,
      currency: "",
      cancelUrl: "",
      successUrl: "",
      failureUrl: "",
      metadata: {},
      totalDiscount: 0n,
      totalTaxAmount: 0n,
      subtotalAmount: 0n,
      lineItems: [],
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<CreateCheckoutRequest>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.amount) {
      json["amount"] = String(msg.amount);
    }
    if (msg.currency) {
      json["currency"] = msg.currency;
    }
    if (msg.cancelUrl) {
      json["cancelUrl"] = msg.cancelUrl;
    }
    if (msg.successUrl) {
      json["successUrl"] = msg.successUrl;
    }
    if (msg.failureUrl) {
      json["failureUrl"] = msg.failureUrl;
    }
    if (msg.metadata) {
      const _metadata_ = Object.fromEntries(
        Object.entries(msg.metadata)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(CreateCheckoutRequestJSON.Metadata._writeMessage)
          .map(({ key, value }) => [key, value]),
      );
      if (Object.keys(_metadata_).length > 0) {
        json["metadata"] = _metadata_;
      }
    }
    if (msg.totalDiscount) {
      json["totalDiscount"] = String(msg.totalDiscount);
    }
    if (msg.totalTaxAmount) {
      json["totalTaxAmount"] = String(msg.totalTaxAmount);
    }
    if (msg.subtotalAmount) {
      json["subtotalAmount"] = String(msg.subtotalAmount);
    }
    if (msg.lineItems?.length) {
      json["lineItems"] = msg.lineItems.map(LineItemJSON._writeMessage);
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: CreateCheckoutRequest,
    json: any,
  ): CreateCheckoutRequest {
    const _amount_ = json["amount"];
    if (_amount_) {
      msg.amount = BigInt(_amount_);
    }
    const _currency_ = json["currency"];
    if (_currency_) {
      msg.currency = _currency_;
    }
    const _cancelUrl_ = json["cancelUrl"];
    if (_cancelUrl_) {
      msg.cancelUrl = _cancelUrl_;
    }
    const _successUrl_ = json["successUrl"];
    if (_successUrl_) {
      msg.successUrl = _successUrl_;
    }
    const _failureUrl_ = json["failureUrl"];
    if (_failureUrl_) {
      msg.failureUrl = _failureUrl_;
    }
    const _metadata_ = json["metadata"];
    if (_metadata_) {
      msg.metadata = Object.fromEntries(
        Object.entries(_metadata_)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(CreateCheckoutRequestJSON.Metadata._readMessage)
          .map(({ key, value }) => [key, value]),
      );
    }
    const _totalDiscount_ = json["totalDiscount"];
    if (_totalDiscount_) {
      msg.totalDiscount = BigInt(_totalDiscount_);
    }
    const _totalTaxAmount_ = json["totalTaxAmount"];
    if (_totalTaxAmount_) {
      msg.totalTaxAmount = BigInt(_totalTaxAmount_);
    }
    const _subtotalAmount_ = json["subtotalAmount"];
    if (_subtotalAmount_) {
      msg.subtotalAmount = BigInt(_subtotalAmount_);
    }
    const _lineItems_ = json["lineItems"];
    if (_lineItems_) {
      for (const item of _lineItems_) {
        const m = LineItemJSON.initialize();
        LineItemJSON._readMessage(m, item);
        msg.lineItems.push(m);
      }
    }
    return msg;
  },

  Metadata: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<CreateCheckoutRequest.Metadata>,
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        json["value"] = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: CreateCheckoutRequest.Metadata,
      json: any,
    ): CreateCheckoutRequest.Metadata {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = _value_;
      }
      return msg;
    },
  },
};

export const CheckoutResponseJSON = {
  /**
   * Serializes CheckoutResponse to JSON.
   */
  encode: function (msg: PartialDeep<CheckoutResponse>): string {
    return JSON.stringify(CheckoutResponseJSON._writeMessage(msg));
  },

  /**
   * Deserializes CheckoutResponse from JSON.
   */
  decode: function (json: string): CheckoutResponse {
    return CheckoutResponseJSON._readMessage(
      CheckoutResponseJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes CheckoutResponse with all fields set to their default value.
   */
  initialize: function (msg?: Partial<CheckoutResponse>): CheckoutResponse {
    return {
      id: "",
      paymentId: "",
      redirectUrl: "",
      status: "",
      amount: 0n,
      currency: "",
      successUrl: "",
      cancelUrl: "",
      failureUrl: "",
      metadata: {},
      merchantId: "",
      totalDiscount: 0n,
      totalTaxAmount: 0n,
      subtotalAmount: 0n,
      lineItems: [],
      processingMode: "",
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<CheckoutResponse>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.id) {
      json["id"] = msg.id;
    }
    if (msg.paymentId) {
      json["paymentId"] = msg.paymentId;
    }
    if (msg.redirectUrl) {
      json["redirectUrl"] = msg.redirectUrl;
    }
    if (msg.status) {
      json["status"] = msg.status;
    }
    if (msg.amount) {
      json["amount"] = String(msg.amount);
    }
    if (msg.currency) {
      json["currency"] = msg.currency;
    }
    if (msg.successUrl) {
      json["successUrl"] = msg.successUrl;
    }
    if (msg.cancelUrl) {
      json["cancelUrl"] = msg.cancelUrl;
    }
    if (msg.failureUrl) {
      json["failureUrl"] = msg.failureUrl;
    }
    if (msg.metadata) {
      const _metadata_ = Object.fromEntries(
        Object.entries(msg.metadata)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(CheckoutResponseJSON.Metadata._writeMessage)
          .map(({ key, value }) => [key, value]),
      );
      if (Object.keys(_metadata_).length > 0) {
        json["metadata"] = _metadata_;
      }
    }
    if (msg.merchantId) {
      json["merchantId"] = msg.merchantId;
    }
    if (msg.totalDiscount) {
      json["totalDiscount"] = String(msg.totalDiscount);
    }
    if (msg.totalTaxAmount) {
      json["totalTaxAmount"] = String(msg.totalTaxAmount);
    }
    if (msg.subtotalAmount) {
      json["subtotalAmount"] = String(msg.subtotalAmount);
    }
    if (msg.lineItems?.length) {
      json["lineItems"] = msg.lineItems.map(LineItemJSON._writeMessage);
    }
    if (msg.processingMode) {
      json["processingMode"] = msg.processingMode;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: CheckoutResponse, json: any): CheckoutResponse {
    const _id_ = json["id"];
    if (_id_) {
      msg.id = _id_;
    }
    const _paymentId_ = json["paymentId"];
    if (_paymentId_) {
      msg.paymentId = _paymentId_;
    }
    const _redirectUrl_ = json["redirectUrl"];
    if (_redirectUrl_) {
      msg.redirectUrl = _redirectUrl_;
    }
    const _status_ = json["status"];
    if (_status_) {
      msg.status = _status_;
    }
    const _amount_ = json["amount"];
    if (_amount_) {
      msg.amount = BigInt(_amount_);
    }
    const _currency_ = json["currency"];
    if (_currency_) {
      msg.currency = _currency_;
    }
    const _successUrl_ = json["successUrl"];
    if (_successUrl_) {
      msg.successUrl = _successUrl_;
    }
    const _cancelUrl_ = json["cancelUrl"];
    if (_cancelUrl_) {
      msg.cancelUrl = _cancelUrl_;
    }
    const _failureUrl_ = json["failureUrl"];
    if (_failureUrl_) {
      msg.failureUrl = _failureUrl_;
    }
    const _metadata_ = json["metadata"];
    if (_metadata_) {
      msg.metadata = Object.fromEntries(
        Object.entries(_metadata_)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(CheckoutResponseJSON.Metadata._readMessage)
          .map(({ key, value }) => [key, value]),
      );
    }
    const _merchantId_ = json["merchantId"];
    if (_merchantId_) {
      msg.merchantId = _merchantId_;
    }
    const _totalDiscount_ = json["totalDiscount"];
    if (_totalDiscount_) {
      msg.totalDiscount = BigInt(_totalDiscount_);
    }
    const _totalTaxAmount_ = json["totalTaxAmount"];
    if (_totalTaxAmount_) {
      msg.totalTaxAmount = BigInt(_totalTaxAmount_);
    }
    const _subtotalAmount_ = json["subtotalAmount"];
    if (_subtotalAmount_) {
      msg.subtotalAmount = BigInt(_subtotalAmount_);
    }
    const _lineItems_ = json["lineItems"];
    if (_lineItems_) {
      for (const item of _lineItems_) {
        const m = LineItemJSON.initialize();
        LineItemJSON._readMessage(m, item);
        msg.lineItems.push(m);
      }
    }
    const _processingMode_ = json["processingMode"];
    if (_processingMode_) {
      msg.processingMode = _processingMode_;
    }
    return msg;
  },

  Metadata: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<CheckoutResponse.Metadata>,
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        json["value"] = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: CheckoutResponse.Metadata,
      json: any,
    ): CheckoutResponse.Metadata {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = _value_;
      }
      return msg;
    },
  },
};

export const RegisterHookRequestJSON = {
  /**
   * Serializes RegisterHookRequest to JSON.
   */
  encode: function (msg: PartialDeep<RegisterHookRequest>): string {
    return JSON.stringify(RegisterHookRequestJSON._writeMessage(msg));
  },

  /**
   * Deserializes RegisterHookRequest from JSON.
   */
  decode: function (json: string): RegisterHookRequest {
    return RegisterHookRequestJSON._readMessage(
      RegisterHookRequestJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes RegisterHookRequest with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<RegisterHookRequest>,
  ): RegisterHookRequest {
    return {
      name: "",
      url: "",
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<RegisterHookRequest>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.name) {
      json["name"] = msg.name;
    }
    if (msg.url) {
      json["url"] = msg.url;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: RegisterHookRequest,
    json: any,
  ): RegisterHookRequest {
    const _name_ = json["name"];
    if (_name_) {
      msg.name = _name_;
    }
    const _url_ = json["url"];
    if (_url_) {
      msg.url = _url_;
    }
    return msg;
  },
};

export const RegisterHookResponseJSON = {
  /**
   * Serializes RegisterHookResponse to JSON.
   */
  encode: function (msg: PartialDeep<RegisterHookResponse>): string {
    return JSON.stringify(RegisterHookResponseJSON._writeMessage(msg));
  },

  /**
   * Deserializes RegisterHookResponse from JSON.
   */
  decode: function (json: string): RegisterHookResponse {
    return RegisterHookResponseJSON._readMessage(
      RegisterHookResponseJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes RegisterHookResponse with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<RegisterHookResponse>,
  ): RegisterHookResponse {
    return {
      id: "",
      name: "",
      url: "",
      mode: "",
      secret: "",
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<RegisterHookResponse>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.id) {
      json["id"] = msg.id;
    }
    if (msg.name) {
      json["name"] = msg.name;
    }
    if (msg.url) {
      json["url"] = msg.url;
    }
    if (msg.mode) {
      json["mode"] = msg.mode;
    }
    if (msg.secret) {
      json["secret"] = msg.secret;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: RegisterHookResponse,
    json: any,
  ): RegisterHookResponse {
    const _id_ = json["id"];
    if (_id_) {
      msg.id = _id_;
    }
    const _name_ = json["name"];
    if (_name_) {
      msg.name = _name_;
    }
    const _url_ = json["url"];
    if (_url_) {
      msg.url = _url_;
    }
    const _mode_ = json["mode"];
    if (_mode_) {
      msg.mode = _mode_;
    }
    const _secret_ = json["secret"];
    if (_secret_) {
      msg.secret = _secret_;
    }
    return msg;
  },
};

export const ListHooksRequestJSON = {
  /**
   * Serializes ListHooksRequest to JSON.
   */
  encode: function (_msg?: PartialDeep<ListHooksRequest>): string {
    return "{}";
  },

  /**
   * Deserializes ListHooksRequest from JSON.
   */
  decode: function (_json?: string): ListHooksRequest {
    return {};
  },

  /**
   * Initializes ListHooksRequest with all fields set to their default value.
   */
  initialize: function (msg?: Partial<ListHooksRequest>): ListHooksRequest {
    return {
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    _msg: PartialDeep<ListHooksRequest>,
  ): Record<string, unknown> {
    return {};
  },

  /**
   * @private
   */
  _readMessage: function (msg: ListHooksRequest, _json: any): ListHooksRequest {
    return msg;
  },
};

export const ListHooksResponseJSON = {
  /**
   * Serializes ListHooksResponse to JSON.
   */
  encode: function (msg: PartialDeep<ListHooksResponse>): string {
    return JSON.stringify(ListHooksResponseJSON._writeMessage(msg));
  },

  /**
   * Deserializes ListHooksResponse from JSON.
   */
  decode: function (json: string): ListHooksResponse {
    return ListHooksResponseJSON._readMessage(
      ListHooksResponseJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes ListHooksResponse with all fields set to their default value.
   */
  initialize: function (msg?: Partial<ListHooksResponse>): ListHooksResponse {
    return {
      subscriptions: [],
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<ListHooksResponse>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.subscriptions?.length) {
      json["subscriptions"] = msg.subscriptions.map(
        ListHooksResponseJSON.Subscriptions._writeMessage,
      );
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: ListHooksResponse,
    json: any,
  ): ListHooksResponse {
    const _subscriptions_ = json["subscriptions"];
    if (_subscriptions_) {
      for (const item of _subscriptions_) {
        const m = ListHooksResponseJSON.Subscriptions.initialize();
        ListHooksResponseJSON.Subscriptions._readMessage(m, item);
        msg.subscriptions.push(m);
      }
    }
    return msg;
  },

  Subscriptions: {
    /**
     * Serializes ListHooksResponse.Subscriptions to JSON.
     */
    encode: function (
      msg: PartialDeep<ListHooksResponse.Subscriptions>,
    ): string {
      return JSON.stringify(
        ListHooksResponseJSON.Subscriptions._writeMessage(msg),
      );
    },

    /**
     * Deserializes ListHooksResponse.Subscriptions from JSON.
     */
    decode: function (json: string): ListHooksResponse.Subscriptions {
      return ListHooksResponseJSON.Subscriptions._readMessage(
        ListHooksResponseJSON.Subscriptions.initialize(),
        JSON.parse(json),
      );
    },

    /**
     * Initializes ListHooksResponse.Subscriptions with all fields set to their default value.
     */
    initialize: function (
      msg?: Partial<ListHooksResponse.Subscriptions>,
    ): ListHooksResponse.Subscriptions {
      return {
        id: "",
        name: "",
        url: "",
        mode: "",
        ...msg,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<ListHooksResponse.Subscriptions>,
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.id) {
        json["id"] = msg.id;
      }
      if (msg.name) {
        json["name"] = msg.name;
      }
      if (msg.url) {
        json["url"] = msg.url;
      }
      if (msg.mode) {
        json["mode"] = msg.mode;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: ListHooksResponse.Subscriptions,
      json: any,
    ): ListHooksResponse.Subscriptions {
      const _id_ = json["id"];
      if (_id_) {
        msg.id = _id_;
      }
      const _name_ = json["name"];
      if (_name_) {
        msg.name = _name_;
      }
      const _url_ = json["url"];
      if (_url_) {
        msg.url = _url_;
      }
      const _mode_ = json["mode"];
      if (_mode_) {
        msg.mode = _mode_;
      }
      return msg;
    },
  },
};

export const DeleteHookRequestJSON = {
  /**
   * Serializes DeleteHookRequest to JSON.
   */
  encode: function (msg: PartialDeep<DeleteHookRequest>): string {
    return JSON.stringify(DeleteHookRequestJSON._writeMessage(msg));
  },

  /**
   * Deserializes DeleteHookRequest from JSON.
   */
  decode: function (json: string): DeleteHookRequest {
    return DeleteHookRequestJSON._readMessage(
      DeleteHookRequestJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes DeleteHookRequest with all fields set to their default value.
   */
  initialize: function (msg?: Partial<DeleteHookRequest>): DeleteHookRequest {
    return {
      id: "",
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<DeleteHookRequest>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.id) {
      json["id"] = msg.id;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: DeleteHookRequest,
    json: any,
  ): DeleteHookRequest {
    const _id_ = json["id"];
    if (_id_) {
      msg.id = _id_;
    }
    return msg;
  },
};

export const DeleteHookResponseJSON = {
  /**
   * Serializes DeleteHookResponse to JSON.
   */
  encode: function (msg: PartialDeep<DeleteHookResponse>): string {
    return JSON.stringify(DeleteHookResponseJSON._writeMessage(msg));
  },

  /**
   * Deserializes DeleteHookResponse from JSON.
   */
  decode: function (json: string): DeleteHookResponse {
    return DeleteHookResponseJSON._readMessage(
      DeleteHookResponseJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes DeleteHookResponse with all fields set to their default value.
   */
  initialize: function (msg?: Partial<DeleteHookResponse>): DeleteHookResponse {
    return {
      message: "",
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<DeleteHookResponse>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.message) {
      json["message"] = msg.message;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: DeleteHookResponse,
    json: any,
  ): DeleteHookResponse {
    const _message_ = json["message"];
    if (_message_) {
      msg.message = _message_;
    }
    return msg;
  },
};

export const LineItemJSON = {
  /**
   * Serializes LineItem to JSON.
   */
  encode: function (msg: PartialDeep<LineItem>): string {
    return JSON.stringify(LineItemJSON._writeMessage(msg));
  },

  /**
   * Deserializes LineItem from JSON.
   */
  decode: function (json: string): LineItem {
    return LineItemJSON._readMessage(
      LineItemJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes LineItem with all fields set to their default value.
   */
  initialize: function (msg?: Partial<LineItem>): LineItem {
    return {
      displayName: "",
      description: "",
      quantity: 0,
      pricingDetails: PricingDetailsJSON.initialize(),
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<LineItem>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.displayName) {
      json["displayName"] = msg.displayName;
    }
    if (msg.description) {
      json["description"] = msg.description;
    }
    if (msg.quantity) {
      json["quantity"] = msg.quantity;
    }
    if (msg.pricingDetails) {
      const _pricingDetails_ = PricingDetailsJSON._writeMessage(
        msg.pricingDetails,
      );
      if (Object.keys(_pricingDetails_).length > 0) {
        json["pricingDetails"] = _pricingDetails_;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: LineItem, json: any): LineItem {
    const _displayName_ = json["displayName"];
    if (_displayName_) {
      msg.displayName = _displayName_;
    }
    const _description_ = json["description"];
    if (_description_) {
      msg.description = _description_;
    }
    const _quantity_ = json["quantity"];
    if (_quantity_) {
      msg.quantity = protoscript.parseNumber(_quantity_);
    }
    const _pricingDetails_ = json["pricingDetails"];
    if (_pricingDetails_) {
      PricingDetailsJSON._readMessage(msg.pricingDetails, _pricingDetails_);
    }
    return msg;
  },
};

export const PricingDetailsJSON = {
  /**
   * Serializes PricingDetails to JSON.
   */
  encode: function (msg: PartialDeep<PricingDetails>): string {
    return JSON.stringify(PricingDetailsJSON._writeMessage(msg));
  },

  /**
   * Deserializes PricingDetails from JSON.
   */
  decode: function (json: string): PricingDetails {
    return PricingDetailsJSON._readMessage(
      PricingDetailsJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes PricingDetails with all fields set to their default value.
   */
  initialize: function (msg?: Partial<PricingDetails>): PricingDetails {
    return {
      price: 0n,
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<PricingDetails>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.price) {
      json["price"] = String(msg.price);
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: PricingDetails, json: any): PricingDetails {
    const _price_ = json["price"];
    if (_price_) {
      msg.price = BigInt(_price_);
    }
    return msg;
  },
};
