// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: workshop/email.service.proto
/* eslint-disable */

import type { ByteSource, PartialDeep } from "protoscript";
import * as protoscript from "protoscript";
import { JSONrequest, PBrequest } from "twirpscript";
// This is the minimum version supported by the current runtime.
// If this line fails typechecking, breaking changes have been introduced and this
// file needs to be regenerated by running `npx twirpscript`.
export { MIN_SUPPORTED_VERSION_0_0_56 } from "twirpscript";
import type { ClientConfiguration } from "twirpscript";

//========================================//
//                 Types                  //
//========================================//

export interface SendEmailRequest {
  sender: Mailer;
  /**
   * Should support multiple recipients in the future
   */
  recipient: Mailer;
  subject: string;
  body: EmailBody;
  attachment: Attachment[];
}

export interface SendEmailResponse {
  message: string;
}

export interface Mailer {
  name: string;
  email: string;
}

/**
 * The emial body can be either text or html
 */
export interface EmailBody {
  text: string;
  html: string;
}

/**
 * Generic definition of an attachment
 */
export interface Attachment {
  fileName: string;
  mimeType: string;
  data: Uint8Array;
}

//========================================//
//      EmailService Protobuf Client      //
//========================================//

/**
 * Send email will be a generic email service interface
 */
export async function SendEmail(
  sendEmailRequest: SendEmailRequest,
  config?: ClientConfiguration,
): Promise<SendEmailResponse> {
  const response = await PBrequest(
    "/workshop.EmailService/SendEmail",
    SendEmailRequest.encode(sendEmailRequest),
    config,
  );
  return SendEmailResponse.decode(response);
}

//========================================//
//        EmailService JSON Client        //
//========================================//

/**
 * Send email will be a generic email service interface
 */
export async function SendEmailJSON(
  sendEmailRequest: SendEmailRequest,
  config?: ClientConfiguration,
): Promise<SendEmailResponse> {
  const response = await JSONrequest(
    "/workshop.EmailService/SendEmail",
    SendEmailRequestJSON.encode(sendEmailRequest),
    config,
  );
  return SendEmailResponseJSON.decode(response);
}

//========================================//
//              EmailService              //
//========================================//

export interface EmailService<Context = unknown> {
  /**
   * Send email will be a generic email service interface
   */
  SendEmail: (
    sendEmailRequest: SendEmailRequest,
    context: Context,
  ) => Promise<SendEmailResponse> | SendEmailResponse;
}

export function createEmailService<Context>(service: EmailService<Context>) {
  return {
    name: "workshop.EmailService",
    methods: {
      SendEmail: {
        name: "SendEmail",
        handler: service.SendEmail,
        input: { protobuf: SendEmailRequest, json: SendEmailRequestJSON },
        output: { protobuf: SendEmailResponse, json: SendEmailResponseJSON },
      },
    },
  } as const;
}

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const SendEmailRequest = {
  /**
   * Serializes SendEmailRequest to protobuf.
   */
  encode: function (msg: PartialDeep<SendEmailRequest>): Uint8Array {
    return SendEmailRequest._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes SendEmailRequest from protobuf.
   */
  decode: function (bytes: ByteSource): SendEmailRequest {
    return SendEmailRequest._readMessage(
      SendEmailRequest.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes SendEmailRequest with all fields set to their default value.
   */
  initialize: function (msg?: Partial<SendEmailRequest>): SendEmailRequest {
    return {
      sender: Mailer.initialize(),
      recipient: Mailer.initialize(),
      subject: "",
      body: EmailBody.initialize(),
      attachment: [],
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<SendEmailRequest>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.sender) {
      writer.writeMessage(1, msg.sender, Mailer._writeMessage);
    }
    if (msg.recipient) {
      writer.writeMessage(2, msg.recipient, Mailer._writeMessage);
    }
    if (msg.subject) {
      writer.writeString(3, msg.subject);
    }
    if (msg.body) {
      writer.writeMessage(4, msg.body, EmailBody._writeMessage);
    }
    if (msg.attachment?.length) {
      writer.writeRepeatedMessage(
        5,
        msg.attachment as any,
        Attachment._writeMessage,
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: SendEmailRequest,
    reader: protoscript.BinaryReader,
  ): SendEmailRequest {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.sender, Mailer._readMessage);
          break;
        }
        case 2: {
          reader.readMessage(msg.recipient, Mailer._readMessage);
          break;
        }
        case 3: {
          msg.subject = reader.readString();
          break;
        }
        case 4: {
          reader.readMessage(msg.body, EmailBody._readMessage);
          break;
        }
        case 5: {
          const m = Attachment.initialize();
          reader.readMessage(m, Attachment._readMessage);
          msg.attachment.push(m);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const SendEmailResponse = {
  /**
   * Serializes SendEmailResponse to protobuf.
   */
  encode: function (msg: PartialDeep<SendEmailResponse>): Uint8Array {
    return SendEmailResponse._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes SendEmailResponse from protobuf.
   */
  decode: function (bytes: ByteSource): SendEmailResponse {
    return SendEmailResponse._readMessage(
      SendEmailResponse.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes SendEmailResponse with all fields set to their default value.
   */
  initialize: function (msg?: Partial<SendEmailResponse>): SendEmailResponse {
    return {
      message: "",
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<SendEmailResponse>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.message) {
      writer.writeString(1, msg.message);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: SendEmailResponse,
    reader: protoscript.BinaryReader,
  ): SendEmailResponse {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.message = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const Mailer = {
  /**
   * Serializes Mailer to protobuf.
   */
  encode: function (msg: PartialDeep<Mailer>): Uint8Array {
    return Mailer._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes Mailer from protobuf.
   */
  decode: function (bytes: ByteSource): Mailer {
    return Mailer._readMessage(
      Mailer.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes Mailer with all fields set to their default value.
   */
  initialize: function (msg?: Partial<Mailer>): Mailer {
    return {
      name: "",
      email: "",
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<Mailer>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.name) {
      writer.writeString(1, msg.name);
    }
    if (msg.email) {
      writer.writeString(2, msg.email);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Mailer,
    reader: protoscript.BinaryReader,
  ): Mailer {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.name = reader.readString();
          break;
        }
        case 2: {
          msg.email = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const EmailBody = {
  /**
   * Serializes EmailBody to protobuf.
   */
  encode: function (msg: PartialDeep<EmailBody>): Uint8Array {
    return EmailBody._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes EmailBody from protobuf.
   */
  decode: function (bytes: ByteSource): EmailBody {
    return EmailBody._readMessage(
      EmailBody.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes EmailBody with all fields set to their default value.
   */
  initialize: function (msg?: Partial<EmailBody>): EmailBody {
    return {
      text: "",
      html: "",
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<EmailBody>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.text) {
      writer.writeString(1, msg.text);
    }
    if (msg.html) {
      writer.writeString(2, msg.html);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: EmailBody,
    reader: protoscript.BinaryReader,
  ): EmailBody {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.text = reader.readString();
          break;
        }
        case 2: {
          msg.html = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const Attachment = {
  /**
   * Serializes Attachment to protobuf.
   */
  encode: function (msg: PartialDeep<Attachment>): Uint8Array {
    return Attachment._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes Attachment from protobuf.
   */
  decode: function (bytes: ByteSource): Attachment {
    return Attachment._readMessage(
      Attachment.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes Attachment with all fields set to their default value.
   */
  initialize: function (msg?: Partial<Attachment>): Attachment {
    return {
      fileName: "",
      mimeType: "",
      data: new Uint8Array(),
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<Attachment>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.fileName) {
      writer.writeString(1, msg.fileName);
    }
    if (msg.mimeType) {
      writer.writeString(2, msg.mimeType);
    }
    if (msg.data?.length) {
      writer.writeBytes(3, msg.data);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Attachment,
    reader: protoscript.BinaryReader,
  ): Attachment {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.fileName = reader.readString();
          break;
        }
        case 2: {
          msg.mimeType = reader.readString();
          break;
        }
        case 3: {
          msg.data = reader.readBytes();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

//========================================//
//          JSON Encode / Decode          //
//========================================//

export const SendEmailRequestJSON = {
  /**
   * Serializes SendEmailRequest to JSON.
   */
  encode: function (msg: PartialDeep<SendEmailRequest>): string {
    return JSON.stringify(SendEmailRequestJSON._writeMessage(msg));
  },

  /**
   * Deserializes SendEmailRequest from JSON.
   */
  decode: function (json: string): SendEmailRequest {
    return SendEmailRequestJSON._readMessage(
      SendEmailRequestJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes SendEmailRequest with all fields set to their default value.
   */
  initialize: function (msg?: Partial<SendEmailRequest>): SendEmailRequest {
    return {
      sender: MailerJSON.initialize(),
      recipient: MailerJSON.initialize(),
      subject: "",
      body: EmailBodyJSON.initialize(),
      attachment: [],
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<SendEmailRequest>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.sender) {
      const _sender_ = MailerJSON._writeMessage(msg.sender);
      if (Object.keys(_sender_).length > 0) {
        json["sender"] = _sender_;
      }
    }
    if (msg.recipient) {
      const _recipient_ = MailerJSON._writeMessage(msg.recipient);
      if (Object.keys(_recipient_).length > 0) {
        json["recipient"] = _recipient_;
      }
    }
    if (msg.subject) {
      json["subject"] = msg.subject;
    }
    if (msg.body) {
      const _body_ = EmailBodyJSON._writeMessage(msg.body);
      if (Object.keys(_body_).length > 0) {
        json["body"] = _body_;
      }
    }
    if (msg.attachment?.length) {
      json["attachment"] = msg.attachment.map(AttachmentJSON._writeMessage);
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: SendEmailRequest, json: any): SendEmailRequest {
    const _sender_ = json["sender"];
    if (_sender_) {
      MailerJSON._readMessage(msg.sender, _sender_);
    }
    const _recipient_ = json["recipient"];
    if (_recipient_) {
      MailerJSON._readMessage(msg.recipient, _recipient_);
    }
    const _subject_ = json["subject"];
    if (_subject_) {
      msg.subject = _subject_;
    }
    const _body_ = json["body"];
    if (_body_) {
      EmailBodyJSON._readMessage(msg.body, _body_);
    }
    const _attachment_ = json["attachment"];
    if (_attachment_) {
      for (const item of _attachment_) {
        const m = AttachmentJSON.initialize();
        AttachmentJSON._readMessage(m, item);
        msg.attachment.push(m);
      }
    }
    return msg;
  },
};

export const SendEmailResponseJSON = {
  /**
   * Serializes SendEmailResponse to JSON.
   */
  encode: function (msg: PartialDeep<SendEmailResponse>): string {
    return JSON.stringify(SendEmailResponseJSON._writeMessage(msg));
  },

  /**
   * Deserializes SendEmailResponse from JSON.
   */
  decode: function (json: string): SendEmailResponse {
    return SendEmailResponseJSON._readMessage(
      SendEmailResponseJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes SendEmailResponse with all fields set to their default value.
   */
  initialize: function (msg?: Partial<SendEmailResponse>): SendEmailResponse {
    return {
      message: "",
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<SendEmailResponse>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.message) {
      json["message"] = msg.message;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: SendEmailResponse,
    json: any,
  ): SendEmailResponse {
    const _message_ = json["message"];
    if (_message_) {
      msg.message = _message_;
    }
    return msg;
  },
};

export const MailerJSON = {
  /**
   * Serializes Mailer to JSON.
   */
  encode: function (msg: PartialDeep<Mailer>): string {
    return JSON.stringify(MailerJSON._writeMessage(msg));
  },

  /**
   * Deserializes Mailer from JSON.
   */
  decode: function (json: string): Mailer {
    return MailerJSON._readMessage(MailerJSON.initialize(), JSON.parse(json));
  },

  /**
   * Initializes Mailer with all fields set to their default value.
   */
  initialize: function (msg?: Partial<Mailer>): Mailer {
    return {
      name: "",
      email: "",
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg: PartialDeep<Mailer>): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.name) {
      json["name"] = msg.name;
    }
    if (msg.email) {
      json["email"] = msg.email;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: Mailer, json: any): Mailer {
    const _name_ = json["name"];
    if (_name_) {
      msg.name = _name_;
    }
    const _email_ = json["email"];
    if (_email_) {
      msg.email = _email_;
    }
    return msg;
  },
};

export const EmailBodyJSON = {
  /**
   * Serializes EmailBody to JSON.
   */
  encode: function (msg: PartialDeep<EmailBody>): string {
    return JSON.stringify(EmailBodyJSON._writeMessage(msg));
  },

  /**
   * Deserializes EmailBody from JSON.
   */
  decode: function (json: string): EmailBody {
    return EmailBodyJSON._readMessage(
      EmailBodyJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes EmailBody with all fields set to their default value.
   */
  initialize: function (msg?: Partial<EmailBody>): EmailBody {
    return {
      text: "",
      html: "",
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<EmailBody>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.text) {
      json["text"] = msg.text;
    }
    if (msg.html) {
      json["html"] = msg.html;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: EmailBody, json: any): EmailBody {
    const _text_ = json["text"];
    if (_text_) {
      msg.text = _text_;
    }
    const _html_ = json["html"];
    if (_html_) {
      msg.html = _html_;
    }
    return msg;
  },
};

export const AttachmentJSON = {
  /**
   * Serializes Attachment to JSON.
   */
  encode: function (msg: PartialDeep<Attachment>): string {
    return JSON.stringify(AttachmentJSON._writeMessage(msg));
  },

  /**
   * Deserializes Attachment from JSON.
   */
  decode: function (json: string): Attachment {
    return AttachmentJSON._readMessage(
      AttachmentJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes Attachment with all fields set to their default value.
   */
  initialize: function (msg?: Partial<Attachment>): Attachment {
    return {
      fileName: "",
      mimeType: "",
      data: new Uint8Array(),
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<Attachment>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.fileName) {
      json["fileName"] = msg.fileName;
    }
    if (msg.mimeType) {
      json["mimeType"] = msg.mimeType;
    }
    if (msg.data?.length) {
      json["data"] = protoscript.serializeBytes(msg.data);
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: Attachment, json: any): Attachment {
    const _fileName_ = json["fileName"] ?? json["file_name"];
    if (_fileName_) {
      msg.fileName = _fileName_;
    }
    const _mimeType_ = json["mimeType"] ?? json["mime_type"];
    if (_mimeType_) {
      msg.mimeType = _mimeType_;
    }
    const _data_ = json["data"];
    if (_data_) {
      msg.data = protoscript.parseBytes(_data_);
    }
    return msg;
  },
};
